// Generated by CoffeeScript 1.10.0
(function() {
  var CONNECTION_KEEPALIVE_MS, CONNECTION_LINGER_MS, CONNECTION_RETRY_MS, Client, Connection, EventEmitter, KEEPALIVE, VERBOSE, _, emitters, helpers, log, randomString, util,
    slice = [].slice;

  util = require('util');

  helpers = require('./helpers');

  _ = require('underscore');

  Connection = require('./connection');

  log = helpers.log, randomString = helpers.randomString;

  EventEmitter = require('events').EventEmitter;

  emitters = require('./events');

  VERBOSE = process.env.SOMATA_VERBOSE || false;

  KEEPALIVE = process.env.SOMATA_KEEPALIVE || true;

  CONNECTION_KEEPALIVE_MS = 6500;

  CONNECTION_LINGER_MS = 1500;

  CONNECTION_RETRY_MS = 2500;

  Client = (function() {
    function Client(options) {
      if (options == null) {
        options = {};
      }
      _.extend(this, options);
      this.events = new EventEmitter;
      this.service_subscriptions = {};
      this.service_connections = {};
      this.registry_connection = new Connection({
        port: 8420
      });
      this.registry_connection.service_instance = {
        id: 'registry'
      };
      this.service_connections['registry'] = this.registry_connection;
      this.registry_connection.sendPing();
      this.registry_connection.on('connect', this.registryConnected.bind(this));
      emitters.exit.onExit((function(_this) {
        return function(cb) {
          log.w('Unsubscribing remote listeners...');
          _this.unsubscribeAll();
          return cb();
        };
      })(this));
      return this;
    }

    return Client;

  })();

  Client.prototype.call = function() {
    var args, cb, i, message_id, method_name, service_name;
    service_name = arguments[0], method_name = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), cb = arguments[i++];
    if (typeof cb !== 'function') {
      if (cb != null) {
        args.push(cb);
      }
      if (VERBOSE) {
        cb = function() {
          return log.w(service_name + ":" + method_name + " completed with no callback.");
        };
      } else {
        cb = null;
      }
    }
    message_id = helpers.randomString(16);
    this.getServiceConnection(service_name, (function(_this) {
      return function(err, service_connection) {
        if (err) {
          log.e(err);
          return cb(err);
        } else {
          return service_connection.sendMethod(message_id, method_name, args, cb);
        }
      };
    })(this));
    return message_id;
  };

  Client.prototype.remote = Client.prototype.call;

  Client.prototype.subscribe = function() {
    var _trySubscribe, args, cb, event_name, i, me, service_name, subscription_id;
    service_name = arguments[0], event_name = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), cb = arguments[i++];
    if (typeof cb !== 'function') {
      if (VERBOSE) {
        log.w(("[Client.subscribe] " + service_name + ":" + event_name + " not a function: ") + cb);
      }
      args.push(cb);
      cb = function() {
        return log.w(service_name + ":" + event_name + " event received with no callback.");
      };
    }
    subscription_id = service_name + ":" + event_name;
    if (args.length) {
      subscription_id += "(" + (args.join(', ')) + ")";
    }
    subscription_id += randomString(4);
    me = this;
    _trySubscribe = function() {
      return me.getServiceConnection(service_name, function(err, service_connection) {
        var service_instance, subscription;
        if (service_connection != null) {
          service_instance = service_connection.service_instance;
          if (VERBOSE) {
            log.i("[Client.subscribe] " + service_instance.id + " : " + event_name);
          }
          subscription = service_connection.sendSubscribe(subscription_id, event_name, args, cb);
          subscription.name = service_name;
          subscription.instance = service_instance;
          subscription.connection = service_connection;
          me.service_subscriptions[subscription_id] = subscription;
          return subscription.connection.on('reconnect', function() {
            if (subscription = me.service_subscriptions[subscription_id]) {
              if (VERBOSE) {
                log.i("[Client.subscribe.reconnect] Going to resubscribe " + subscription_id);
              }
              delete subscription.connection.pending_responses[subscription_id];
              return _trySubscribe();
            }
          });
        } else {
          if (VERBOSE) {
            log.w("[Client.subscribe] Going to retry subscription to " + service_name);
          }
          return setTimeout(_trySubscribe, 1500);
        }
      });
    };
    _trySubscribe();
    return subscription_id;
  };

  Client.prototype.on = Client.prototype.subscribe;

  Client.prototype.unsubscribe = function(_sub_id) {
    return _.chain(this.service_subscriptions).pairs().filter(function(pair) {
      return pair[0] === _sub_id;
    }).map((function(_this) {
      return function(pair, _cb) {
        var sub, sub_id;
        sub_id = pair[0], sub = pair[1];
        sub.connection.sendUnsubscribe(sub_id, sub.type);
        return delete _this.service_subscriptions[sub_id];
      };
    })(this));
  };

  Client.prototype.unsubscribeAll = function() {
    return _.pairs(this.service_subscriptions).map((function(_this) {
      return function(arg, _cb) {
        var sub, sub_id;
        sub_id = arg[0], sub = arg[1];
        return _this.getServiceConnection(sub.instance.name, function(err, service_connection) {
          return service_connection.sendUnsubscribe(sub_id, sub.type);
        });
      };
    })(this));
  };

  Client.prototype.bindRemote = function(service_name) {
    return this.remote.bind(this, service_name);
  };

  Client.prototype.getServiceConnection = function(service_name, cb) {
    var service_connection;
    service_name = service_name;
    if (service_connection = this.service_connections[service_name]) {
      cb(null, service_connection);
      return;
    }
    return this.registry_connection.sendMethod(null, 'getService', [service_name], (function(_this) {
      return function(err, service_instance) {
        if (err) {
          return cb(err);
        }
        if (VERBOSE) {
          log.i("New connection to " + service_instance.id);
        }
        service_connection = new Connection({
          port: service_instance.port
        });
        service_connection.service_instance = service_instance;
        service_connection.on('failure', function() {
          return _this.closeConnection(service_instance);
        });
        _this.service_connections[service_name] = service_connection;
        return cb(null, service_connection);
      };
    })(this));
  };

  Client.prototype.registryConnected = function() {
    this.closeAllConnections();
    this.resubscribeAll();
    return this.subscribe('registry', 'deregister', this.deregistered.bind(this));
  };

  Client.prototype.closeAllConnections = function() {
    var ref, results, service_connection, service_id;
    ref = this.service_connections;
    results = [];
    for (service_id in ref) {
      service_connection = ref[service_id];
      if (service_id !== 'registry') {
        results.push(this.closeConnection(service_connection.service_instance));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Client.prototype.deregistered = function(service_instance) {
    var service_connection;
    if (service_connection = this.service_connections[service_instance.name]) {
      this.closeConnection(service_instance);
      return this.resubscribe(service_instance.id);
    }
  };

  Client.prototype.resubscribe = function(service_id) {
    var ref, results, subscription, subscription_id;
    ref = this.service_subscriptions;
    results = [];
    for (subscription_id in ref) {
      subscription = ref[subscription_id];
      if (subscription.instance.id === service_id) {
        results.push(subscription.connection.emit('reconnect'));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Client.prototype.resubscribeAll = function() {
    var ref, results, service_id, service_name, subscription, subscription_id;
    ref = this.service_subscriptions;
    results = [];
    for (subscription_id in ref) {
      subscription = ref[subscription_id];
      service_id = subscription.instance.id;
      service_name = subscription.name;
      if (service_name !== 'registry') {
        results.push(this.resubscribe(service_id));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Client.prototype.closeConnection = function(service_instance) {
    var doClose, service_connection, service_name;
    service_name = service_instance.name;
    if (VERBOSE) {
      log.w("[closeConnection] " + service_name);
    }
    service_connection = this.service_connections[service_name];
    delete this.service_connections[service_name];
    doClose = function() {
      if (VERBOSE) {
        log.w("[closeConnection] Connection to " + service_name + " closed after linger");
      }
      return service_connection.close();
    };
    return setTimeout(doClose, CONNECTION_LINGER_MS);
  };

  module.exports = Client;

}).call(this);
