// Generated by CoffeeScript 1.10.0
(function() {
  var CONNECTION_KEEPALIVE_MS, CONNECTION_LINGER_MS, CONNECTION_RETRY_MS, Client, Connection, EventEmitter, KEEPALIVE, VERBOSE, _, emitters, helpers, log, randomString, util,
    slice = [].slice;

  util = require('util');

  helpers = require('./helpers');

  _ = require('underscore');

  Connection = require('./connection');

  log = helpers.log, randomString = helpers.randomString;

  EventEmitter = require('events').EventEmitter;

  emitters = require('./events');

  VERBOSE = process.env.SOMATA_VERBOSE || true || false;

  KEEPALIVE = process.env.SOMATA_KEEPALIVE || true;

  CONNECTION_KEEPALIVE_MS = 6500;

  CONNECTION_LINGER_MS = 1500;

  CONNECTION_RETRY_MS = 2500;

  Client = (function() {
    function Client(options) {
      if (options == null) {
        options = {};
      }
      _.extend(this, options);
      this.connection_manager = new EventEmitter;
      this.service_subscriptions = {};
      this.service_connections = {};
      this.registry_connection = new Connection({
        port: 8420
      });
      this.registry_connection.service_instance = {
        id: 'registry'
      };
      this.registry_connection.sendPing();
      this.registry_connection.on('connect', this.subscribeDeregisters.bind(this));
      this.service_connections['registry'] = this.registry_connection;
      emitters.exit.onExit((function(_this) {
        return function(cb) {
          log.w('Unsubscribing remote listeners...');
          _this.unsubscribeAll();
          return cb();
        };
      })(this));
      return this;
    }

    Client.prototype.subscribeDeregisters = function() {
      return this.subscribe('registry', 'deregister', this.closeConnection.bind(this));
    };

    return Client;

  })();

  Client.prototype.call = function() {
    var args, cb, i, message_id, method_name, service_name;
    service_name = arguments[0], method_name = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), cb = arguments[i++];
    if (typeof cb !== 'function') {
      if (cb != null) {
        args.push(cb);
      }
      if (VERBOSE) {
        cb = function() {
          return log.w(service_name + ":" + method_name + " completed with no callback.");
        };
      } else {
        cb = null;
      }
    }
    message_id = helpers.randomString(16);
    this.getServiceConnection(service_name, (function(_this) {
      return function(err, service_connection) {
        if (err) {
          log.e(err);
          return cb(err);
        } else {
          return service_connection.sendMethod(message_id, method_name, args, cb);
        }
      };
    })(this));
    return message_id;
  };

  Client.prototype.remote = Client.prototype.call;

  Client.prototype.subscribe = function() {
    var _trySubscribe, args, cb, event_name, i, me, service_name, subscription_id;
    service_name = arguments[0], event_name = arguments[1], args = 4 <= arguments.length ? slice.call(arguments, 2, i = arguments.length - 1) : (i = 2, []), cb = arguments[i++];
    if (typeof cb !== 'function') {
      log.w(("[Client.subscribe] " + service_name + ":" + event_name + " not a function: ") + cb);
      args.push(cb);
      cb = function() {
        return log.w(service_name + ":" + event_name + " event received with no callback.");
      };
    }
    subscription_id = service_name + ":" + event_name;
    if (args.length) {
      subscription_id += "(" + (args.join(', ')) + ")";
    }
    subscription_id += randomString(4);
    me = this;
    _trySubscribe = function() {
      return me.getServiceConnection(service_name, function(err, service_connection) {
        var service, subscription;
        if (service_connection != null) {
          service = service_connection.service_instance;
          log.i("[Client.subscribe] " + service.id + " : " + event_name);
          subscription = service_connection.sendSubscribe(subscription_id, event_name, args, cb);
          subscription.service = service_name;
          subscription.connection = service_connection;
          return me.service_subscriptions[subscription_id] = subscription;
        } else {
          log.w('Going to retry subscription');
          return setTimeout(_trySubscribe, 1500);
        }
      });
    };
    _trySubscribe();
    return subscription_id;
  };

  Client.prototype.on = Client.prototype.subscribe;

  Client.prototype.unsubscribe = function(_sub_id) {
    return _.chain(this.service_subscriptions).pairs().filter(function(pair) {
      return pair[0] === _sub_id;
    }).map((function(_this) {
      return function(pair, _cb) {
        var sub, sub_id;
        sub_id = pair[0], sub = pair[1];
        sub.connection.sendUnsubscribe(sub_id, sub.event_name);
        return delete _this.service_subscriptions[sub_id];
      };
    })(this));
  };

  Client.prototype.unsubscribeAll = function() {
    return _.pairs(this.service_subscriptions).map(function(arg, _cb) {
      var sub, sub_id;
      sub_id = arg[0], sub = arg[1];
      return sub.connection.sendUnsubscribe(sub_id, sub.event_name);
    });
  };

  Client.prototype.bindRemote = function(service_name) {
    return this.remote.bind(this, service_name);
  };

  Client.prototype.getServiceConnection = function(service_name, cb) {
    var service_connection;
    service_name = service_name;
    if (service_connection = this.service_connections[service_name]) {
      cb(null, service_connection);
      return;
    }
    return this.registry_connection.sendMethod(null, 'getService', [service_name], (function(_this) {
      return function(err, service_instance) {
        if (err) {
          return cb(err);
        }
        log.i("New connection to " + service_instance.id);
        service_connection = new Connection({
          port: service_instance.port
        });
        service_connection.service_instance = service_instance;
        service_connection.on('failure', function() {
          console.log('seeming failure');
          return _this.closeConnection(service_instance);
        });
        _this.service_connections[service_name] = service_connection;
        return cb(null, service_connection);
      };
    })(this));
  };

  Client.prototype.purgeDeadServiceConnections = function() {
    return this.getUnhealthyServiceInstances((function(_this) {
      return function(err, unhealthy_instances) {
        return unhealthy_instances.each(function(instance) {
          if (_this.service_connections[instance.Service.Service] != null) {
            return _this.closeConnection(instance);
          }
        });
      };
    })(this));
  };

  Client.prototype.closeConnection = function(service_instance) {
    var doClose, service_connection, service_name;
    service_name = service_instance.name;
    if (VERBOSE) {
      log.w('[closeConnection] ' + service_name);
    }
    if (service_connection = this.service_connections[service_name]) {
      delete this.service_connections[service_name];
      doClose = function() {
        if (VERBOSE) {
          log.w("Closing connection to " + service_name + "...");
        }
        return service_connection.close();
      };
      return setTimeout(doClose, CONNECTION_LINGER_MS);
    } else {
      return log.w("Already closed?");
    }
  };

  module.exports = Client;

}).call(this);
