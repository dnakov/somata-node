// Generated by CoffeeScript 1.10.0
(function() {
  var Connection, DEFAULT_CONNECT, DEFAULT_PROTO, EventEmitter, PING_INTERVAL, VERBOSE, _, log, randomString, ref, util, zmq,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  zmq = require('zmq');

  util = require('util');

  _ = require('underscore');

  EventEmitter = require('events').EventEmitter;

  ref = require('./helpers'), log = ref.log, randomString = ref.randomString;

  VERBOSE = process.env.SOMATA_VERBOSE || false;

  DEFAULT_PROTO = process.env.SOMATA_PROTO || 'tcp';

  DEFAULT_CONNECT = process.env.SOMATA_CONNECT || '127.0.0.1';

  PING_INTERVAL = parseInt(process.env.SOMATA_PING_INTERVAL) || 2000;

  module.exports = Connection = (function(superClass) {
    extend(Connection, superClass);

    Connection.prototype.pending_responses = {};

    function Connection(options) {
      if (options == null) {
        options = {};
      }
      if (VERBOSE) {
        log.d('[Connection.constructor]', options);
      }
      _.extend(this, options);
      this.id || (this.id = randomString());
      this.proto || (this.proto = DEFAULT_PROTO);
      this.host || (this.host = DEFAULT_CONNECT);
      this.address = this.proto + '://' + this.host;
      if (this.proto !== 'ipc') {
        this.address += ':' + this.port;
      }
      this.connect();
    }

    Connection.prototype.connect = function() {
      this.socket = zmq.socket('dealer');
      this.socket.identity = this.id;
      this.socket.connect(this.address);
      this.socket.on('message', (function(_this) {
        return function(message_json) {
          return _this.handleMessage(JSON.parse(message_json));
        };
      })(this));
      if (VERBOSE) {
        return log("Socket " + this.id + " connected to " + this.address + "...");
      }
    };

    Connection.prototype.handleMessage = function(message) {
      var on_response;
      if (VERBOSE) {
        log("[connection.handleMessage] " + (util.inspect(message).slice(0, 100).replace(/\s+/g, ' ')));
      }
      if (on_response = this.pending_responses[message.id]) {
        if (on_response.timeout != null) {
          clearTimeout(on_response.timeout);
        }
        if (message.kind === 'response') {
          on_response(null, message.response);
          return delete this.pending_responses[message.id];
        } else if (message.kind === 'error') {
          on_response(message.error, null);
          return delete this.pending_responses[message.id];
        } else if (message.kind === 'event') {
          return on_response(message.event);
        } else if (message.kind === 'end') {
          on_response(null, true);
          return delete this.pending_responses[message.id];
        }
      } else {
        return log.w('[handleMessage] No pending response for ' + message.id, this.pending_responses);
      }
    };

    Connection.prototype.setPending = function(message_id, on_response) {
      var dotimeout;
      if (this.timeout_ms) {
        dotimeout = (function(_this) {
          return function() {
            log.e("[TIMEOUT] Timing out request " + message_id);
            on_response({
              timeout: _this.timeout_ms,
              message: "Timed out"
            });
            return delete _this.pending_responses[message_id];
          };
        })(this);
        on_response.timeout = setTimeout(dotimeout, this.timeout_ms);
      }
      return this.pending_responses[message_id] = on_response;
    };

    Connection.prototype.send = function(message, on_response) {
      message.id || (message.id = randomString(16));
      if (on_response != null) {
        this.setPending(message.id, on_response);
      }
      this.socket.send(JSON.stringify(message));
      return message;
    };

    Connection.prototype.sendMethod = function(id, method_name, args, cb) {
      var method_msg;
      method_msg = {
        id: id,
        kind: 'method',
        method: method_name,
        args: args
      };
      return this.send(method_msg, cb);
    };

    Connection.prototype.sendSubscribe = function(id, event_name, args, cb) {
      var subscribe_msg;
      subscribe_msg = {
        id: id,
        kind: 'subscribe',
        type: event_name,
        args: args
      };
      return this.send(subscribe_msg, cb);
    };

    Connection.prototype.sendUnsubscribe = function(id, event_name) {
      var unsubscribe_msg;
      unsubscribe_msg = {
        id: id,
        kind: 'unsubscribe',
        type: event_name
      };
      this.send(unsubscribe_msg);
      return delete this.pending_responses[id];
    };

    Connection.prototype.last_ping = null;

    Connection.prototype.sendPing = function(ping_again) {
      var pingTimeout, ping_msg;
      if (ping_again == null) {
        ping_again = true;
      }
      ping_msg = {
        kind: 'ping'
      };
      pingTimeout = setTimeout(this.pingDidTimeout.bind(this), PING_INTERVAL / 2);
      return this.last_ping = this.send(ping_msg, (function(_this) {
        return function(err, pong) {
          if (pong === 'hello') {
            log.i("New ping response");
            _this.emit('connect');
          } else if (pong !== 'pong') {
            log.e("Ping response not OK");
            _this.emit('failure');
          } else {
            log.d("[" + _this.service_instance.id + "] Continuing ping");
          }
          clearTimeout(pingTimeout);
          if (ping_again) {
            return setTimeout(_this.sendPing.bind(_this), PING_INTERVAL);
          }
        };
      })(this));
    };

    Connection.prototype.pingDidTimeout = function() {
      log.e("[" + this.service_instance.id + "] Ping timed out");
      return this.emit('failure');
    };

    Connection.prototype.close = function() {
      return this.socket.close();
    };

    return Connection;

  })(EventEmitter);

}).call(this);
