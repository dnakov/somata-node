#!/usr/bin/env node
// Generated by CoffeeScript 1.7.1
(function() {
  var BargeRegistry, HEARTBEAT_INTERVAL, HEARTBEAT_TIMEOUT, REGISTRATION_TIMEOUT, REGISTRY_DEFAULTS, VERBOSE, argv, log, minimist, randomChoice, randomString, util, zmq, _, _ref;

  util = require('util');

  zmq = require('zmq');

  _ref = require('./helpers'), log = _ref.log, randomString = _ref.randomString, randomChoice = _ref.randomChoice;

  _ = require('underscore');

  VERBOSE = true;

  HEARTBEAT_INTERVAL = 5000;

  HEARTBEAT_TIMEOUT = HEARTBEAT_INTERVAL * 3;

  REGISTRATION_TIMEOUT = HEARTBEAT_INTERVAL * 2;

  exports.DEFAULTS = REGISTRY_DEFAULTS = {
    proto: 'tcp',
    bind: '0.0.0.0',
    host: process.env.BARGE_REGISTRY_HOST || 'localhost',
    port: process.env.BARGE_REGISTRY_PORT || 9910
  };

  BargeRegistry = (function() {
    BargeRegistry.prototype.pending_registrations = {};

    BargeRegistry.prototype.registered_services = {};

    BargeRegistry.prototype.registered_clients = {};

    function BargeRegistry(options) {
      if (options == null) {
        options = {};
      }
      options = _.defaults(options, REGISTRY_DEFAULTS);
      this.address = options.proto + '://' + options.bind + ':' + options.port;
      this.socket = zmq.socket('router');
      this.socket.bindSync(this.address);
      this.socket.on('message', (function(_this) {
        return function(client_id, message_json) {
          return _this.handleMessage(client_id.toString(), JSON.parse(message_json));
        };
      })(this));
      this.startCheckups();
      log("Barge registry listening on " + this.address + "...");
    }

    BargeRegistry.prototype.send = function(client_id, message) {
      return this.socket.send([client_id, JSON.stringify(message)]);
    };

    BargeRegistry.prototype.handleMessage = function(client_id, message) {
      if (VERBOSE) {
        log("<" + client_id + ">: " + (util.inspect(message)));
      }
      switch (message.type) {
        case 'register':
          return this.handleRegister(client_id, message);
        case 'unregister':
          return this.handleUnregister(client_id);
        case 'heartbeat':
          return this.handleHeartbeat(client_id, message);
        case 'query':
          return this.handleQuery(client_id, message);
        default:
          return log('Unrecognized message: ' + util.inspect(message));
      }
    };

    BargeRegistry.prototype.handleRegister = function(client_id, message) {
      var service;
      service = message.args;
      service.client_id = client_id;
      if (this.registered_clients[client_id] == null) {
        log.i("New service registered: " + service.name + " (" + client_id + ")");
      } else {
        log.i("Re-registering service: " + service.name + " (" + client_id + ")");
      }
      if (!this.registered_services[service.name]) {
        this.registered_services[service.name] = [];
      }
      this.registered_services[service.name].push(service);
      this.registered_clients[client_id] = service;
      this.registered_clients[client_id].last_seen = new Date().getTime();
      if (this.pending_registrations[client_id] != null) {
        return delete this.pending_registrations[client_id];
      }
    };

    BargeRegistry.prototype.handleUnregister = function(client_id) {
      var service, service_instances;
      if (service = this.registered_clients[client_id]) {
        service_instances = this.registered_services[service.name];
        service_instances = _.reject(service_instances, function(s) {
          return s.client_id === client_id;
        });
        this.registered_services[service.name] = service_instances;
        delete this.registered_clients[client_id];
        return log.e("Unregistered service: " + service.name + " <" + client_id + ">");
      }
    };

    BargeRegistry.prototype.handleHeartbeat = function(client_id, message) {
      var now;
      now = new Date().getTime();
      if (this.registered_clients[client_id] == null) {
        if ((this.pending_registrations[client_id] == null) || (now - this.pending_registrations[client_id]) > REGISTRATION_TIMEOUT) {
          this.send(client_id, {
            command: 'register?'
          });
          return this.pending_registrations[client_id] = now;
        }
      } else {
        return this.registered_clients[client_id].last_seen = now;
      }
    };

    BargeRegistry.prototype.handleQuery = function(client_id, message) {
      var service, service_name, services;
      service_name = message.args.service_name;
      services = this.registered_services[service_name];
      if (services != null ? services.length : void 0) {
        service = randomChoice(services);
        log("Found service: " + (util.inspect(service)), {
          color: 'green'
        });
        return this.send(client_id, {
          id: message.id,
          service: service
        });
      } else {
        log("Could not find service: " + service_name, {
          color: 'yellow'
        });
        return this.send(client_id, {
          id: message.id,
          service: null
        });
      }
    };

    BargeRegistry.prototype.startCheckups = function() {
      return setInterval(((function(_this) {
        return function() {
          return _this.checkup();
        };
      })(this)), 500);
    };

    BargeRegistry.prototype.checkup = function() {
      var client, client_id, now, _ref1, _results;
      now = new Date().getTime();
      _ref1 = this.registered_clients;
      _results = [];
      for (client_id in _ref1) {
        client = _ref1[client_id];
        if ((now - client.last_seen) > HEARTBEAT_TIMEOUT) {
          _results.push(this.handleUnregister(client_id));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return BargeRegistry;

  })();

  if (require.main === module) {
    minimist = require('minimist');
    argv = minimist(process.argv.slice(2));
    new BargeRegistry(argv);
  }

}).call(this);
